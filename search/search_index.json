{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rye: An Experimental Package Management Solution for Python","text":"<p>Rye is Armin's personal one-stop-shop for all his Python needs.  It installs and manages Python installations, helps working with <code>pyproject.toml</code> files, installs and uninstalls dependencies, creates and updates virtualenvs behind the scenes.  It supports monorepos and global tool installations.</p> <p>Rye is an experimental endeavour to build a new type of packaging experience to Python inspired by <code>rustup</code> and <code>cargo</code> from Rust.  It's not yet production ready but feedback and suggestions are greatly appreciated.</p> <p> Star Discuss Sponsor </p> Installation Instructions LinuxmacOSWindowsCompile Yourself <p>To install run you can curl a command which will install the right binary for your operating system and CPU architecture and install it:</p> <pre><code>curl -sSf https://rye-up.com/get | bash\n</code></pre> <p>Alternatively if you don't trust this approach, you can download the latest release binary.  On first run it will install itself.</p> <ul> <li>rye-x86_64-linux.gz for 64bit Intel computers</li> <li>rye-aarch64-linux.gz for 64bit ARM computers</li> </ul> <pre><code>gunzip rye-x86_64-linux.gz\nchmod +x ./rye-x86_64-linux\n./rye-x86_64-linux\n</code></pre> <p>To install run you can curl a command which will install the right binary for your operating system and CPU architecture and install it:</p> <pre><code>curl -sSf https://rye-up.com/get | bash\n</code></pre> <p>Alternatively if you don't trust this approach, you can download the latest release binary.  On first run it will install itself.</p> <ul> <li>rye-aarch64-macos.gz for M1/M2 Macs</li> <li>rye-x86_64-macos.gz for Intel Macs</li> </ul> <pre><code>gunzip rye-aarch64-macos.gz\nchmod +x ./rye-aarch64-macos\n./rye-aarch64-macos\n</code></pre> <p>To install Rye on windows download the latest release and run the binary.  Upon first run it will install itself.  Please note that it's strongly recommended to have \"Developer Mode\" activated when using Rye and before starting the installation.  Learn more.</p> <ul> <li>rye-x86_64-windows.exe for 64bit Intel Windows</li> <li>rye-x86-windows.exe for 32bit Intel Windows</li> </ul> <p>Note</p> <p>Rye does not yet use signed binaries which means that you will need to allow the execution of the downloaded executable.  If there is no obvious way to do so, click on \"More info\" on the error message that shows up and then on \"Run anyway\".</p> <p>You need to have Rust and Cargo installed.  If you don't have, you can use rustup to get them onto your machine.</p> <p>Afterwards you can install <code>Rye</code> via <code>cargo</code>:</p> <pre><code>cargo install --git https://github.com/mitsuhiko/rye rye\n</code></pre> <p>For the next steps or ways to customize the installation, head over to the detailed installation guide.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Here you can find all the released changes to Rye.  If you want to also see the in-development changes that were not released yet, refer to the CHANGELOG.md file in the repository.</p>"},{"location":"changelog/#0130","title":"0.13.0","text":"<p>Released on 2023-08-29</p> <ul> <li> <p>Add a <code>python3</code> shim on windows.  Previously entering <code>python3</code> in the   command line would always bring up the windows store python proxy even   when global shims were enabled.  As virtualenvs do not support the   <code>python3</code> executable on windows, the internal shim handling is now also   changed so that trying to launch <code>python3</code> will fall back to <code>python</code>.   This makes it possible to run <code>maturin build</code>.</p> </li> <li> <p>Add <code>maturin</code> build command to start a new maturin PyO3 project.</p> </li> </ul>"},{"location":"changelog/#0120","title":"0.12.0","text":"<p>Released on 2023-08-27</p> <ul> <li> <p>Improve handling of the pth files for TCL on pypy. #409</p> </li> <li> <p>The <code>rye tools list</code> command now accepts <code>-v</code> to also print out the   versions of the installed tools. #396</p> </li> <li> <p>Fixed parsing of versions by <code>rye version</code>. #397</p> </li> <li> <p>Improved the help message for <code>rye init</code>. #401</p> </li> <li> <p>The email address now defaults to a syntactically valid email address   if not known to prevent errors with some build tools.</p> </li> <li> <p>Added new Python versions.</p> </li> <li> <p>The rye installer now detects <code>NOEXEC</code> temporary folders and prints out   a more helpful error message. #394</p> </li> <li> <p>Fixed an issue where the author email was incorrectly detected. #382</p> </li> <li> <p>The prompt of new virtualenvs is now set to the project name. #383</p> </li> </ul>"},{"location":"changelog/#0110","title":"0.11.0","text":"<p>Released on 2023-07-18</p> <ul> <li> <p>Added new Python versions.</p> </li> <li> <p>Added a new config key <code>default.author</code> to configure the default author   that should be set.  This overrides the default author that is normally   loaded from the git config.  #377</p> </li> <li> <p>When importing with <code>rye init</code> and no <code>src</code> folder exists, it will not be   created.  #375</p> </li> <li> <p>Added support for <code>shell</code> command on Windows.  #363</p> </li> <li> <p>Pin down pip to an older version to avoid issues with an incompatible   <code>pip-tools</code> version.  This does not yet update pip-tools to 7.0 as there   are significant regressions in 7.x. #374</p> </li> <li> <p>The <code>version</code> command can show dynamic versions now. #355</p> </li> <li> <p><code>rye add</code> now properly checks some incompatible argument combinations.  #347</p> </li> <li> <p>There is now more toolchain validation.  This better supports cases where   rye was interrupted during sync.  #351</p> </li> </ul>"},{"location":"changelog/#0100","title":"0.10.0","text":"<p>Released on 2023-07-07</p> <ul> <li> <p>Fixed a bug with <code>rye init</code> not operating correctly due to a argument conflict.  #346</p> </li> <li> <p>Scripts now support a PDM style <code>call</code> script type.  #345</p> </li> <li> <p>The <code>init</code> command is now capable of importing existing projects.  #265</p> </li> <li> <p>Fixed the global shim behavior on Windows.  #344</p> </li> </ul>"},{"location":"changelog/#090","title":"0.9.0","text":"<p>Released on 2023-06-21</p> <ul> <li> <p>The internal Rye Python version is now 3.11.</p> </li> <li> <p>Rye now emits most messages, most of the time to stdout rather than stderr.  #342</p> </li> <li> <p><code>rye add</code> now accepts <code>--pin</code> to let one override the type of pin to use.  #341</p> </li> <li> <p>Added <code>rye config</code> to read and manipulate the <code>config.toml</code> file.  #339</p> </li> <li> <p>Added support for the new <code>behavior.global-python</code> flag which turns on global   Python shimming.  When enabled then the <code>python</code> shim works even outside of   Rye managed projects.  Additionally the shim (when run outside of Rye managed   projects) supports a special first parameter <code>+VERSION</code> which requests a   specific version of Python (eg: <code>python +3.8</code> to request Python 3.8).  #336</p> </li> <li> <p>Renamed the config key <code>default.dependency_operator</code> to <code>default.dependency-operator</code>   and <code>behavior.force_rye_managed</code> to <code>behavior.force-rye-managed</code>.  #338</p> </li> </ul>"},{"location":"changelog/#080","title":"0.8.0","text":"<p>Released on 2023-06-18</p> <ul> <li> <p>Rye for now prefers <code>&gt;=</code> over <code>~=</code> for newly added dependencies.</p> </li> <li> <p>The workspace member declaration is now platform independent.  If <code>members</code> is   now explicitly set to an empty list it will not fall back to auto discovery.  #331</p> </li> <li> <p><code>rye add</code> now pins versions with <code>==</code> instead of <code>~=</code> when the version of the   package does not use at least two components.  This means that for instance it   will now correctly use <code>openai-whisper==20230314</code> rather than   <code>openai-whisper~=20230314</code> which is not actually satisfiable.  #328</p> </li> <li> <p><code>rye install</code> now lets you install dependencies into the tool's virtualenv   during installation that are undeclared via the new <code>--extra-requirement</code>   option.  #326</p> </li> <li> <p>Improved handling of relative path installations by setting <code>PROJECT_ROOT</code>   the same way as PDM does.  #321</p> </li> <li> <p>Workspaces will now never discover <code>pyproject.toml</code> files in any dot   directories. (Name starting with <code>.</code>)  #329</p> </li> <li> <p>Fixed <code>rye build</code> not working correctly on Windows.  #327</p> </li> </ul>"},{"location":"changelog/#070","title":"0.7.0","text":"<p>Released on 2023-06-12</p> <ul> <li> <p><code>rye sync</code> and <code>rye lock</code> now accept <code>--pyproject</code>.  #296</p> </li> <li> <p>Added JSON output to <code>rye toolchain list</code> by adding <code>--format=json</code>.  #306</p> </li> <li> <p><code>rye version</code> can bump version by <code>--bump</code> option now.  #298</p> </li> <li> <p>Fixed members not handled correctly in workspaces.  #300</p> </li> <li> <p>Add <code>--clean</code> for <code>build</code> command.  #297</p> </li> <li> <p>Fixed an issue where pip was not invoked from the right working directory   causing issues for workspace installations.  #292</p> </li> <li> <p><code>rye init</code> now accepts <code>--private</code> to set the <code>Private :: Do Not Upload</code> classifier   that prevents uploads to PyPI.  #291</p> </li> </ul>"},{"location":"changelog/#060","title":"0.6.0","text":"<p>Released on 2023-06-03</p> <ul> <li> <p>Add <code>version</code> subcommand for rye. #285</p> </li> <li> <p>Fixed <code>rye pin</code> pinning the wrong version.  #288</p> </li> <li> <p>Calling <code>rye init</code> on the root directory no longer fails.  #274</p> </li> <li> <p><code>rye run</code>, <code>show</code>, <code>pin</code>, <code>shell</code> and <code>build</code> now take a <code>--pyproject</code>   argument. #232</p> </li> </ul>"},{"location":"changelog/#050","title":"0.5.0","text":"<p>Released on 2023-05-31</p> <ul> <li> <p>Rye will no longer enforce a downloaded interpreter for the internal   toolchain.  If one has been registered that is compatible it will be   used.  Additionally the installer now supports the <code>RYE_TOOLCHAIN</code>   environment variable which allows a user to supply an already existing   Python interpreter at install time.  #267</p> </li> <li> <p>The <code>publish</code> command now supports <code>--yes</code> to disable prompts.  #270</p> </li> <li> <p>When a Python debug build (<code>Py_DEBUG</code>) is registered as custom toolchain,   <code>-dbg</code> is automatically appended to the name by default.  #269</p> </li> <li> <p>lto+pgo builds are now preferred for the Python toolchain builds when   available.  #268</p> </li> <li> <p>It's now possible for <code>.python-version</code> to request partial Python versions   in which case the latest available is used.  In particular this means that   a version like <code>3.10</code> can be written into <code>.python-version</code> rather than   <code>3.10.11</code>.  This can be accomplished by invoking <code>pin</code> with the new   <code>--relaxed</code> flag.  #255</p> </li> <li> <p>Workspaces will no longer discover <code>pyproject.toml</code> files in virtualenvs   or <code>.git</code> folders.  #266</p> </li> <li> <p>Adding or removing dependencies with <code>add</code> or <code>remove</code> now reformats   the <code>dependencies</code> array in the <code>pyproject.toml</code> file to multi-line   with trailing commas.  This should result in significantly better   diffing behavior out of the box.  #263</p> </li> <li> <p>Default build-system and license can be specified in global config.  #244</p> </li> <li> <p>Fixed an issue where the <code>init</code> command would not let you create   <code>flit</code> based projects.  #254</p> </li> <li> <p>Resolve an error (\"No such file or directory\") shown after updates on   Linux machines.  #252</p> </li> <li> <p>The built-in updater now validates checksums of updates when updates have   SHA-256 hashes available.  #253</p> </li> <li> <p><code>init</code> now accepts <code>--no-pin</code> to not create a <code>.python-version</code> file.  #247</p> </li> </ul>"},{"location":"changelog/#040","title":"0.4.0","text":"<p>Released on 2023-05-29</p> <ul> <li> <p>Releases starting with <code>0.4.0</code> onwards are published with SHA256 checksum   files for all release assets.  These files are not yet validated by the   installer or updater however.</p> </li> <li> <p>The <code>install</code> command can now install tools from custom indexes.  #240</p> </li> <li> <p>Virtualenvs on Unix are now created with a hack to pre-configure TCL and   TKinter.  #233</p> </li> <li> <p>Fix invalid version error when using rye init with custom toolchain.  #234</p> </li> <li> <p>Failed tool installations now properly clean up.  #225</p> </li> <li> <p>Correctly swap the rye executable on windows when performing an update   to a git version via <code>self update</code>.</p> </li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>Released on 2023-05-27</p> <ul> <li> <p>Support retrieving username and repository-url from credentials if not   provided for the <code>publish</code> command.  #217</p> </li> <li> <p>The installer now validates the availability of shared libraries   on Linux with <code>ldd</code> and emits an error with additional information   if necessary shared libraries are missing.  #220</p> </li> <li> <p>It's now possible to configure http and https proxies.  #215</p> </li> <li> <p>If a package is not found because it only has matching pre-releases,   a warning is now printed to tell the user to pass <code>--pre</code>.  #218</p> </li> <li> <p>Add <code>--username</code> parameter for rye publish.  #211</p> </li> <li> <p>The shims are now more resilient.  Previously a <code>pyproject.toml</code> file   caused in all cases a virtualenv to be created.  Now this will only   happen when the <code>rye.tool.managed</code> flag is set to <code>true</code>.  The old   behavior can be forced via the global config.  #212</p> </li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>Released on 2023-05-23</p> <ul> <li> <p>Resolved a bug where on Windows hitting the shift key (or some other keys)   in confirm prompts would cause an error.</p> </li> <li> <p>The installer on Windows now warns if symlinks are not enabled and directs   the user to enable developer mode.  The <code>--version</code> output now also   shows if symlinks are available.  #205</p> </li> <li> <p>Support auto fix requires-python when there is a conflict. #160</p> </li> <li> <p>Added support for custom indexes.  #199</p> </li> <li> <p><code>rye add</code> no longer complains when a local version information is   in the version.  #199</p> </li> </ul>"},{"location":"changelog/#012","title":"0.1.2","text":"<p>Released on 2023-05-22</p> <ul> <li> <p>Fixed dev-dependencies not being installed when using workspace.  #170</p> </li> <li> <p><code>init</code> no longer creates invalid flit config.  #195</p> </li> <li> <p>Support direct references when adding a package.  #158</p> </li> <li> <p>Fixed a bug with uninstall on Unix platforms.  #197</p> </li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>Released on 2023-05-18</p> <ul> <li> <p>The installer on windows will now ask for a key to be pressed so it does   not close the window without information.  #183</p> </li> <li> <p>Fixed an issue on macOS where the installer would die with \"os error 24\"   when directly piped to bash.  #184</p> </li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>Released on 2023-05-17</p> <ul> <li> <p>Rye now comes with binary releases for some platforms.</p> </li> <li> <p>A new <code>self uninstall</code> command was added to uninstall rye and the new   <code>self update</code> command updates to the latest release version.</p> </li> <li> <p>Rye now includes a <code>publish</code> command for publishing Python packages to a   package repository.  #86</p> </li> <li> <p>Script declarations in <code>pyproject.toml</code> now permit chaining and custom   environment variables.  #153</p> </li> <li> <p>Added <code>tools install</code> and <code>tools uninstall</code> as aliases for <code>install</code> and   <code>uninstall</code> and added <code>tools list</code> to show all installed tools.</p> </li> <li> <p>Rye is now capable of downloading a selected set of PyPy releases.  To do   so use <code>rye pin pypy@3.9.16</code> or any other supported PyPy release.</p> </li> <li> <p>Custom cpython toolchains are now registered just as <code>cpython</code> rather   than <code>custom-cpython</code>.</p> </li> <li> <p>Rye now supports Python down to 3.7.</p> </li> <li> <p>Rye's <code>self</code> command now includes a <code>completion</code> subcommand to generate   a completion script for your shell.</p> </li> <li> <p>The downloaded Python distributions are now validated against the   SHA-256 hashes.</p> </li> <li> <p>Rye now builds on windows.  This is even more experimental though   than support for Linux and macOS.</p> </li> <li> <p>Added <code>--features</code> and <code>--all-features</code> for <code>lock</code> and <code>sync</code>.</p> </li> <li> <p>Rye will now look at the <code>RYE_HOME</code> to determine the location of the   <code>.rye</code> folder.  If it's not set, <code>$HOME/.rye</code> is used as before.</p> </li> <li> <p>Rye now has a most consistent handling for virtualenv versions.  If   <code>.python-version</code> is provided, that version is used.  Otherwise if   <code>requires-python</code> is set in the <code>pyproject.toml</code>, that version is used   instead.  When a new project is created the <code>.python-version</code> file is   written and the current latest cpython version is picked.</p> </li> <li> <p>It's now possible to explicitly set the <code>name</code> of the project when   initializing a new one.</p> </li> <li> <p>Rye's <code>init</code> command now attempts to initialize projects with <code>git</code> and   will automatically create a <code>src/project_name/__init__.py</code> file.</p> </li> <li> <p>Rye can now also generate a license text when initializing projects.</p> </li> <li> <p>Rye now supports negative (exclusion) dependencies.  These can be used to   prevent a dependency from installing, even if something else in the graph   depends on it.  Use <code>rye add --exclude package-name</code> to add such a dependency.</p> </li> <li> <p><code>sync</code> now accepts <code>--no-lock</code> to prevent updating the lock file.</p> </li> <li> <p>Rye's <code>add</code> command now accepts a <code>--pre</code> parameter to include pre-release.</p> </li> <li> <p>Rye's <code>pin</code> command now updates the pyproject.toml requires-python.</p> </li> <li> <p>Rye's <code>install</code> command now accepts a <code>--include-dep</code> parameter to include   scripts from one or more given dependencies.</p> </li> <li> <p>Rye now honors <code>requires-python</code> in the <code>add</code> command.  This means the the   initial resolution will not pick a version higher than what's supported by   the lower boundary.</p> </li> <li> <p>When installing packages as global tools, a warning is now emitted if there   were no scripts in the package.  Additionally installing packages from local   paths and zip files is now supported.</p> </li> <li> <p>A <code>rye self update</code> command was added to compile and install the latest   version via cargo.</p> </li> <li> <p>Added more convenient ways to install from git/urls by supplying a <code>--git</code>   or <code>--url</code> parameter.  This will behind the scenes format a PEP 508 requirement   string.</p> </li> <li> <p>Added a <code>shell</code> command which will spawn a shell with the virtualenv activated.</p> </li> <li> <p>Added a <code>make-req</code> command to conveniently format out PEP 508 requirement   strings from parts.</p> </li> <li> <p>The internal virtualenv used to manage <code>pip-tools</code> and other libraries now   automatically updates when necessary.</p> </li> <li> <p><code>rye toolchain register</code> can now be used to register a local python installation   as toolchain with rye.</p> </li> <li> <p><code>rye build</code> was added to allow building <code>sdist</code> and <code>bdist_wheel</code> distributions.</p> </li> <li> <p>Rye now correctly handles whitespace in folder names.</p> </li> </ul>"},{"location":"community/","title":"Community","text":"<p>Rye is a new project and feedback is greatly appreciated.  Lots of it.  Because of this there are various different ways in which you can engage with either the developer or other members of the community:</p> <ul> <li>Discussion Forum, to discuss the project   on GitHub</li> <li>Discord, for conversations with other developers in text form</li> <li>Issue Tracker, if you run into bugs or have suggestions</li> </ul> <p>You can also reach out via Twitter or Bluesky.</p>"},{"location":"philosophy/","title":"Philosophy and Vision","text":"<p>Rye was built to solve my problems.  Here is what was on my mind when I built it:</p> <ul> <li> <p>Virtualenvs: while I personally do not like virtualenvs that much, they are   so widespread and have reasonable tooling support, so I chose this over   <code>__pypackages__</code>.</p> </li> <li> <p>No Default Dependencies: the virtualenvs when they come up are completely void   of dependencies. Not even <code>pip</code> or <code>setuptools</code> are installed into it. Rye   manages the virtualenv from outside the virtualenv.</p> </li> <li> <p>No Core Non Standard Stuff: Rye (with the exception of it's own <code>tool</code> section   in the <code>pyproject.toml</code>) uses standardized keys. That means it uses regular   requirements as you would expect. It also does not use a custom lock file   format and uses <code>pip-tools</code> behind the scenes.</p> </li> <li> <p>No Pip: Rye uses pip, but it does not expose it. It manage dependencies in   <code>pyproject.toml</code> only.</p> </li> <li> <p>No System Python: I can't deal with any more linux distribution weird Python   installations or whatever mess there is on macOS. I used to build my own Pythons   that are the same everywhere, now I use indygreg's Python builds.   Rye will automatically download and manage Python builds from there. No compiling,   no divergence.</p> </li> <li> <p>Project Local Shims: Rye maintains a <code>python</code> shim that auto discovers the   current <code>pyproject.toml</code> and automatically operates below it. Just add the   shims to your shell and you can run <code>python</code> and it will automatically always   operate in the right project.</p> </li> </ul>"},{"location":"philosophy/#what-could-be","title":"What Could Be?","text":"<p>There are a few shortcomings in the Python packaging world, largely as a result of lack of standardization. Here is what this project ran into over the years:</p> <ul> <li> <p>No Python Binary Distributions: CPython builds from python.org are completely   inadequate. On some platforms you only get an .msi installer, on some you   literally only get tarballs. The various Python distributions that became popular   over the years are diverging greatly and cause all kinds of nonsense downstream.   This is why this Project uses the indygreg standalone builds. I hope that with   time someone will start distributing well maintained and reliable Python builds   to replace the mess we are dealing with today.</p> </li> <li> <p>No Dev Dependencies: Rye currently needs a custom section in the <code>pyproject.toml</code>   to represent dev dependencies. There is no standard in the ecosystem for this. It   really should be added.</p> </li> <li> <p>No Local Dependency Overlays: There is no standard for how to represent local   dependencies. Rust for this purpose has something like <code>{ path = \"../foo\" }</code>   which allows both remote and local references to co-exist and it rewrites them   on publish.</p> </li> <li> <p>No Exposed Pip: pip is intentionally not exposed. If you were to install something   into the virtualenv, it disappears next time you sync. If you symlink <code>rye</code> to   <code>~/.rye/shims/pip</code> you can get access to pip without installing it into the   virtualenv. There be dragons.</p> </li> <li> <p>No Workspace Spec: for monorepos and things of that nature, the Python ecosystem   would need a definition of workspaces. Today that does not exist which forces every   tool to come up with it's own solutions to this problem.</p> </li> <li> <p>No Basic Script Section: There should be a standard in <code>pyproject.toml</code> to   represent scripts like <code>rye</code> does in <code>rye.tools.scripts</code>.</p> </li> </ul>"},{"location":"philosophy/#the-vision","title":"The Vision","text":"<p>This describes of what I envision Python packaging and project management could look like in an ideal world:</p>"},{"location":"philosophy/#the-rust-experience","title":"The Rust Experience","text":"<p>Coming from a Rust environment there are two tools which work together: <code>rustup</code> and <code>cargo</code>.  The first one of those is used to ensure that you have the correct Rust toolchain on your machine.  Rust greatly prefers binary distributions of the language from the official website over external distributions.</p> <p><code>cargo</code> is the main entry point to development in Rust.  It acts as the tool to trigger test runs, start the build process, shell out to the documentation building tool, linters but also things such as workspace management, dependency management and package publishing.</p> <p>Crucially a very important aspect of the Rust development experience is the strong commitment to semver and the built-in support for it.  This goes very deep.  The resolver for instance will deduplicate matching dependencies throughout the graph. This means that if four libraries depend on <code>libc@0.2</code>, they will all resolve to that dependency.  However if another need arises for <code>libc@1.0</code>, then it's possible for the dependency graph to result in both being loaded!</p> <p>The ecosystem greatly depends on this.  For instance when a new major release is made of a very core library, in some cases extra care is taken to unify the now incompatible versions by re-exporting core types from the newer to the older version.  Thus it's for instance possible for <code>important-lib@0.2.32</code> to depend on <code>important-lib@1.0</code> internally so it can make the transition easier.</p> <p>Additionally Rust heavily leverages lockfiles.  Whenever you compile, the dependencies are locked in place and future builds reuse the same dependency versions unless you update.</p> <p>Most importantly though the Rust ecosystem has embraced <code>rustup</code> and <code>cargo</code> that the vast majority of people are using these tools on a daily basis.  Even developers who pick other tools like buck, are still using <code>cargo</code> regularly.</p>"},{"location":"philosophy/#going-python","title":"Going Python","text":"<p>Rye wants to explore if such an experience is possible with Python.  I believe it can! There is quite a lot of the ecosystem that can be leveraged for this purpose but there is even more that would need to be built.</p> <p>Important note: when you read \"rye\" in the context of the document it talks about what a potential tool like rye could be.  It might as well be that one of the many tools that exist today, turn into that very tool that is described here.</p> <p>My sentiment is that unless \"the one tool\" can emerge in the Python world, the introduction of yet another tool might be a neg-negative to the ecosystem.  Plenty of tools have been created over the years, and unfortunately it hasn't been able to rally the majority of the Python community behind any tool.  I do however believe it is possible.</p>"},{"location":"philosophy/#bootstrapping-python","title":"Bootstrapping Python","text":"<p>I believe the right approach is that &gt;95% of users get a Python distribution via <code>rye</code> and not to have <code>rye</code> pick up a system installed Python distribution.  There are good reasons for using a system Python installation, but it should be the exception not the rule.  Most importantly because a Python distribution that <code>rye</code> puts in place can be made to have reliable and simple rules that do not differ between systems.</p> <p>A huge cause of confusion and user frustration currently comes from Linux distribution specific patches on top of Python that break tools and change behavior, particularly in the python packaging ecosystem.</p> <p>Bootstrapping Python via an independent tool has other benefits as well.  It for instance allows much easier cross-python version testing via tox or CI.</p> <p>What needs to be done:</p> <ul> <li>Provide widely available Python builds, with largely standardized structure   retrievable from the internet. PEP 711 is a step   in that direction.</li> </ul>"},{"location":"philosophy/#a-stronger-resolver","title":"A Stronger Resolver","text":"<p>Today there are a ton of different resolvers in the Python ecosystem.  Pip has two, poetry has one, pdm has one, different independent Python and Rust resolvers exist on top of that. Resolvers are important, but unfortunately are are both too many and too many issues with the existing ones.  Here is what I believe a resolver needs to be able to accomplish:</p> <ul> <li> <p>Allow resolving across markers: most resolvers in the Python ecosystem today can only   resolve for the current interpreter and platform (eg: pip, pip-tools).  This means it cannot   create a resolution that is equally valid for a different platform.  In parts this is   a problem because of how environment markers in Python are defined.  They allow a level of   expressiveness that cannot be reflected by most tools, however a subset could be supported.</p> </li> <li> <p>Multi-version resolution support: this is a bit foreshadowing, but I believe for a   variety of reasons it needs to be possible for a resolver to not unify all requirements   to a single version, but to support multiple independent resolutions across major versions   of libraries.  A future resolver should be able to permit <code>package==2.0</code> and <code>package==1.1</code>   to both be resolved for different parts of the tree.</p> </li> <li> <p>Resolver API: access to the resolver is important.  For editor plugins, or custom   tools it's always necessary to be able to resolve packages.  For instance if you want   something as trivial as \"add latest supported version of 'flask' to my <code>pyproject.toml</code>\"   you need to be able to work with the resolver.</p> </li> <li> <p>Filters: I strongly believe that a good resolver also needs a filter on top.  For   instance it must be possible for a developer to restrict the resolver to stay within the   bounds of the target Python version and to never upgrade into a tree containing Python   versions that are too new.  Likewise for supply chain safety a resolver should be able to   restrict itself to a set of vetted dependencies.</p> </li> </ul> <p>What needs to be done:</p> <ul> <li>Create a reusable resolver that can be used by multiple tools in the ecosystem.</li> <li>Make the resolver work with the proposed metadata cache</li> <li>Expose the resolver as API for multiple tools to use.</li> <li>Add a policy layer into the resolver that can be used to filter down the dependencies   before use.</li> </ul>"},{"location":"philosophy/#metadata-caches","title":"Metadata Caches","text":"<p>Because of the rather simplistic nature of Python packages and package indexes a resolver will always be restricted by the metadata that it can reliably pull.  This is particularly bad if the system needs to fall back to <code>sdist</code> uploads which in the worst case requires executing python code to determine the dependencies, and those dependencies might not even match on different platforms.</p> <p>However this is a solvable problem with sufficient caching, and with the right design for the cache, this cache could be shared.  It might even be quite interesting for PyPI to serve up \"fake\" metadata records for popular sdist only packages to help resolvers.  This might go a long way in improving the quality of the developer experience.</p> <p>What needs to be done:</p> <ul> <li>Local metadata caches are added for the resolver to use</li> <li>PyPI gains the ability to serve dependency meta data</li> </ul>"},{"location":"philosophy/#lockfiles","title":"Lockfiles","text":"<p>It's unclear if a standard can emerge for lock files given the different requirements, but a Python packaging solution needs to have support for these.  There are a lot of different approaches to lockfiles today (poetry and pdm for instance have them) but it's not entirely clear to me that the way they are handled today is sufficiently pragmatic to enable a tool that is based on lockfiles to get majority adoption.</p> <p>The reason in part relates the suboptimal situation with resolvers (eg: large projects can take ten minutes or longer to dependency check in poetry), on the other hand however also because of the reality of how dependencies are currently declared.  For instance certain libraries will \"over\" depend on third party libraries, even if they are not needed for a developer.  These pulled in dependencies however will still influence the resolver.</p> <p>Most importantly a good lockfile also covers platforms other than the current developer's machine.  This means that if a project supports Windows and Linux, the lockfile should be handling either dependency trees.  This is what cargo accomplishes today, but cargo has a a much simpler problem to solve here because it has perfect access to package metadata which resolvers in Python do not have today.  What is also problematic in Python is that certain parts of the dependency tree can be version dependent.  In Rust a library A either depends on library B or it does not, but it does not depend on it conditional to a Python version.</p> <p>The total expressiveness of Python dependencies is challenging.  The lack of good metadata access for the resolver combined with the ability to make dependencies optional conditional to the Python version is tricky by itself.  The complexity however is compounded by the fact that the resolver needs to come to a solution that can only result in a single resolved version per package.</p> <p>What needs to be done:</p> <ul> <li>Experiment with a restricted lock format that satisfies a subset of what markers provide   today, that strikes a good balance.</li> <li>Provide lockfile support as part of the resolver library.</li> </ul>"},{"location":"philosophy/#upper-bounds-multi-versioning","title":"Upper Bounds &amp; Multi Versioning","text":"<p>Resolving Python dependencies is particularly challenging because a single solution must be found per package.  A reason this works at all in the Python ecosystem is that most libraries do not set upper bounds.  This means that they will be eagerly accepting future libraries even at the cost of not supporting them.  That's largely possible because Python is a dynamic language and a lot of flexibility is usually possible here.  However with increased utilization of type information in the Python world, and maybe with stronger desires for proper locking, it might be quite likely that upper version bounds become more common.</p> <p>Once that happens however, the Python ecosystem will quite quickly run into blocking future upgrades until the entire dependency graph has moved up which creates a lot of friction. Other ecosystems have solved this problem by strictly enforcing semver semantics onto packages and by permitting multiple semver incompatible libraries to be loaded simultaneously.  While usually a library is only allowed to permit on a single version of a dependency, that dependency can exist in different versions throughout the dependency tree.</p> <p>In Python there is a perceived worry that this cannot be accomplished because of how site-packages, <code>PYTHONPATH</code> and <code>sys.modules</code> works.  However I believe these to be solvable issues.  On the one hand because <code>.pth</code> files can be used to completely change how the import system works, secondly because the <code>importlib.metadata</code> API is strong enough these days to allow a package to resolve it's own metadata.  The combination of the two can be used to \"redirect\" imports in <code>sys.modules</code> and import statements to ensure that if a library imports a dependency of itself, it ends up with the right version.</p> <p>What needs to be done:</p> <ul> <li>Add a new metadata key to <code>pyproject.toml</code> that declares that a package supports multi-versioning</li> <li>Enforce semver semantics on multi-version dependencies</li> <li>Provide an import hook that provides multi-version imports as part of Rye</li> <li>Relax the resolver to permit multiple solutions for multi-version dependencies</li> </ul>"},{"location":"philosophy/#workspaces-and-local-multi-path-references","title":"Workspaces and Local / Multi Path References","text":"<p>With growing development teams one of the most frustrating experiences is the inability to break up a monolithic Python module into smaller modules without having to constantly publish minor versions to a package index.  The way the Rust ecosystem deals with this issue is two-fold: on the one hand Rust supports workspaces natively.  Workspaces share dependencies and the resolver results.  The equivalent in Python would be that a workspace shares a virtualenv across all of the projects within in.  The second way in which Rust solves this problem is to permit a dependency to both support declaration of the package name, index but also local reference.</p> <p>While also Rust does not permit a crate to be published to a package index with references to packages outside of the index, a separate rewrite step kicks in ahead of publish to clean out invalid dependency references.  If no valid reference remains, the package will not publish.</p> <p>What needs to be done:</p> <ul> <li>requirement declarations need to be expanded to support defining the name of the index where   they can be found, and optional local path references.</li> </ul>"},{"location":"philosophy/#every-project-in-a-virtualenv","title":"Every Project in a Virtualenv","text":"<p>While virtualenv is not by favorite tool, it's the closest we have to a standard.  I proposed that there is always one path for a virtualenv <code>.venv</code> and when Rye manages it, users should not interact with it manually.  It's at that point rye's responsibility to manage it, and it shall manage it as if it was a throw-away, always re-creatable scratch-pad for dependencies.</p> <p>Preferably over time the structure of virtualenvs aligns between different Python versions (eg: Windows vs Linux) and the deeply nested <code>lib/py-ver/site-packages</code> structure is flattened out.</p> <p>What needs to be done:</p> <ul> <li>Agree on a name for where managed virtualenvs are placed (eg: <code>.venv</code> in the workspace root)</li> </ul>"},{"location":"philosophy/#dev-and-tool-dependencies","title":"Dev and Tool Dependencies","text":"<p>Another topic that is currently unresolved across tools in the ecosystem is how to work with dependencies that are not used in production.  For instance it's quite common that a certain dependency really only matters on the developer's machine.  Today pdm and some other tools have custom sections in the <code>pyproject.toml</code> file to mark development dependencies, but there is no agreement across tools on it.</p> <p>What needs to be done:</p> <p>There needs to be an agreed upon standard for all tools.  See this discussion</p>"},{"location":"philosophy/#opinionated-defaults","title":"Opinionated Defaults","text":"<p>Python against PEP-8's wishes just has too many ways in which things can be laid out.  There should be a much stronger push towards encouraging common standards:</p> <p>What needs to be done:</p> <ul> <li>Rye shall ship with the one true formatter</li> <li>Rye shall ship with the one true linter</li> <li>Rye shall always create a preferred folder structure for new projects</li> <li>Rye shall loudly warn if <code>package-foo</code> does not provide a <code>package_foo</code> module</li> </ul>"},{"location":"philosophy/#existing-tools","title":"Existing Tools","text":"<p>Some of the existing tools in the ecosystem are close, and there is a good chance that some of these might be able to combine forces to create that one-true tool.  I hope that there is enough shared interest, that we don't end up with three tools that all try to be Rye.</p>"},{"location":"guide/","title":"Introduction","text":"<p>Rye is still a very experimental tool, but this guide is here to help you get started.  Before we dive into the installation and basic usage guide it's important for you to understand what Rye actually is.</p> <p>Rye is a one-stop-shop tool.  The idea is that as a Python developer all you need to know is Rye, because Rye is your start into the experience.  As a Rye user you do not even need to install Python yourself as Rye does this for you. This means to use Rye, you just need to install Rye, the rest is done by Rye itself.</p> <p>Once Rye is on your system, it can automatically install Python interpreters for you, install packages from package indexes, manage virtualenvs behind the scenes and more.</p> <p>Interested?  Then head over to Installation to learn about how to get Rye onto your system.  Once that is done, read the Basics to learn about how Rye can be used.</p>"},{"location":"guide/basics/","title":"Basics","text":"<p>To use Rye you need to have a <code>pyproject.toml</code> based Python project.  For this guide you can create one with <code>rye init</code> which will create a new folder with a new project inside:</p> <pre><code>rye init my-project\ncd my-project\n</code></pre> <p>The following structure will be created:</p> <pre><code>.\n\u251c\u2500\u2500 .git\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .python-version\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 my_project\n        \u2514\u2500\u2500 __init__.py\n</code></pre> <p>Good to Know</p> <p>The <code>init</code> command accepts a lot of options to customize what it generates.  Run <code>rye init --help</code> to see all the options available in the version you have installed.</p> <p>A <code>pyproject.toml</code> is used to store metadata about your project as well as some Rye configuration.  Most of Rye's commands will require a <code>pyproject.toml</code> to work.  Note that Rye today does not support <code>setup.py</code> based projects.  Note that when Rye initializes a project it also writes a <code>.python-version</code> file.  This file contains the version number of the Python version that should be used for this project.  It can be changed by running <code>rye pin</code>.  For instance to tell Rye to use Python 3.10:</p> <pre><code>$ rye pin 3.10\n</code></pre>"},{"location":"guide/basics/#first-sync","title":"First Sync","text":"<p>Once that is done, you can use <code>rye sync</code> to get the first synchronization.  After that, Rye will have created a virtualenv in <code>.venv</code> and written lockfiles into <code>requirements.lock</code> and <code>requirements-dev.lock</code>.</p> <pre><code>rye sync\n</code></pre> <p>The virtualenv that Rye manages is placed in <code>.venv</code> next to your <code>pyproject.toml</code>. The first time you run this you will notice that Rye automatically downloaded and installed a compatible CPython interpreter for you.  If you have already another Python installation on your system it will not be used!  For more information about this behavior read about toolchains.</p> <p>You can activate and work with it as normal with one notable exception: the Python installation in it does not contain <code>pip</code>.  If you have correctly installed Rye with the shims enabled, after the sync you can run <code>python</code> and you will automatically be operating in that virtualenv, even if it's not enabled.  You can validate this by printing out <code>sys.prefix</code>:</p> <pre><code>python -c \"import sys; print(sys.prefix)\"\n</code></pre> <p>It will print out the full path to the managed virtualenv.</p>"},{"location":"guide/basics/#adding-dependencies","title":"Adding Dependencies","text":"<p>Use the <code>add</code> command to add dependencies to your project.</p> <pre><code>rye add \"flask&gt;=2.0\"\n</code></pre> <p>Note that after <code>add</code> you need to run <code>sync</code> again to actually install it.  If you want to add packages from custom indexes, you have to configure the source first.</p>"},{"location":"guide/basics/#remove-a-dependency","title":"Remove a Dependency","text":"<p>Use the <code>remove</code> command to remove a dependency from the project again.</p> <pre><code>rye remove flask\n</code></pre>"},{"location":"guide/basics/#working-with-the-project","title":"Working with the Project","text":"<p>To run executables in the context of the virtualenv you can use the <code>run</code> command.  For instance if you want to use <code>black</code> you can add and run it like this:</p> <pre><code>rye add black\nrye sync\nrye run black\n</code></pre> <p>To activate the virtualenv, use the standard methods:</p> UnixWindows <pre><code>. .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>To deactivate it again run <code>deactivate</code>:</p> <pre><code>deactivate\n</code></pre>"},{"location":"guide/config/","title":"Configuration","text":"<p>Most of Rye's configuration is contained within the <code>pyproject.toml</code> file.  There is however also a bit of global configuration to influence how it works.</p>"},{"location":"guide/config/#changing-home-folder","title":"Changing Home Folder","text":"<p>By default Rye places all it's configuration in <code>~/.rye</code> on Unix and <code>%USERPROFILE%\\.rye</code> on Windows.  This behavior can be changed via the <code>RYE_HOME</code> environment variable.  This is useful if you do not like the default location of where Rye places it's configuration or if you need to isolate it.</p>"},{"location":"guide/config/#home-folder-structure","title":"Home Folder Structure","text":"<p>The <code>.rye</code> home folder contains both user configuration as well as Rye managed state such as installed toolchains.  The following files and folders are placed within the <code>.rye</code> folder.  Note that not all are there always.</p>"},{"location":"guide/config/#configtoml","title":"<code>config.toml</code>","text":"<p>This is a configuration file that influences how Rye operates.  Today very little configuration is available there.  For the available config keys see Config File.</p>"},{"location":"guide/config/#self","title":"<code>self</code>","text":"<p>While Rye is written in Rust, it uses a lot of Python tools internally.  These are maintained in an internal virtualenv stored in this location.</p>"},{"location":"guide/config/#py","title":"<code>py</code>","text":"<p>In this folder Rye stores the different toolchains.  Normally those are folders containing downloaded Python distributions, but they can also be symlinks or special reference files.</p>"},{"location":"guide/config/#shims","title":"<code>shims</code>","text":"<p>This folder contains shim binaries.  These binaries are for instance the <code>python</code> executable which automatically proxies to the current virtualenv or globally installed tools.</p>"},{"location":"guide/config/#config-file","title":"Config File","text":"<p>The config file <code>config.toml</code> in the <code>.rye</code> folder today only is used to manage defaults.  This is a fully annotated config file:</p> <pre><code>[default]\n# This is the default value that is written into new pyproject.toml\n# files for the `project.requires-python` key\nrequires-python = \"&gt;= 3.8\"\n\n# This is the default toolchain that is used\ntoolchain = \"cpython@3.11.1\"\n\n# This is the default build system that is used\nbuild-system = \"hatchling\"\n\n# This is the default license that is used\nlicense = \"MIT\"\n\n# This sets the default author (overrides the defaults from git).  The\n# format here is \"Name &lt;email&gt;\".\nauthor = \"Full Name &lt;email@address.invalid&gt;\"\n\n# The dependency operator to use by default for dependencies.  The options are\n# '&gt;=', '~=', and '=='.  The default currently is '&gt;='.  This affects the behavior\n# of `rye add`.\ndependency-operator = \"&gt;=\"\n\n[proxy]\n# the proxy to use for HTTP (overridden by the http_proxy environment variable)\nhttp = \"http://127.0.0.1:4000\"\n# the proxy to use for HTTPS (overridden by the https_proxy environment variable)\nhttps = \"http://127.0.0.1:4000\"\n\n[behavior]\n# When set to true the `managed` flag is always assumed to be true.\nforce-rye-managed = false\n\n# Enables global shims when set to `true`.  This means that the installed\n# `python` shim will resolve to a Rye managed toolchain even outside of\n# virtual environments.\nglobal-python = false\n\n# a array of tables with optional sources.  Same format as in pyproject.toml\n[[sources]]\nname = \"default\"\nurl = \"http://pypi.org/simple/\"\n</code></pre>"},{"location":"guide/config/#manipulating-config","title":"Manipulating Config","text":"<p>new in 0.9.0</p> <p>The configuration can be read and modified with <code>rye config</code>.  The keys are in dotted notation.  <code>--get</code> reads a key, <code>--set</code>, <code>--set-int</code>, <code>--set-bool</code>, or <code>--unset</code> modify one.</p> <pre><code>rye config --set proxy.http=http://127.0.0.1:4000\nrye config --set-bool behavior.rye-force-managed=true\nrye config --get default.requires-python\n</code></pre>"},{"location":"guide/config/#per-project-config","title":"Per Project Config","text":"<p>For the project specific <code>pyproject.toml</code> config see pyproject.toml.</p>"},{"location":"guide/deps/","title":"Dependencies","text":"<p>Dependencies are declared in pyproject.toml however adding them can be simplified with the <code>rye add</code> command.  In the most simple invocation it adds a regular dependency, but it can be customized.</p>"},{"location":"guide/deps/#adding-basic-dependency","title":"Adding Basic Dependency","text":"<p>To add a regular dependency just invoke <code>rye add</code> with the name of the Python package:</p> <pre><code>rye add Flask\n</code></pre> <p>If you also want to define a version, use a PEP 508 requirement:</p> <pre><code>rye add \"Flask&gt;=2.0\"\n</code></pre> <p>For extra/feature dependencies you can either use PEP 508 syntax or use <code>--features</code>:</p> <pre><code>rye add \"Flask[dotenv]\"\nrye add Flask --features=dotenv\n</code></pre> <p>These dependencies are stored in <code>project.dependencies</code>.</p> <p>Note about pre-releases</p> <p>By default <code>add</code> will not consider pre-releases.  This means if you add a dependency that has <code>.dev</code> or similar in the version number you will not find a match.  To consider them, add them with <code>--pre</code>:</p> <pre><code>rye add \"Flask==2.0.0rc2\" --pre\n</code></pre>"},{"location":"guide/deps/#development-dependencies","title":"Development Dependencies","text":"<p>For dependencies that should only be installed during development pass <code>--dev</code></p> <pre><code>rye add --dev black\n</code></pre> <p>These dependencies are stored in the non-standard <code>tool.rye.dev-dependencies</code> key.</p> <p>To run tools added this way without enabling the virtualenv use <code>rye run</code>:</p> <pre><code>rye run black\n</code></pre>"},{"location":"guide/deps/#git-local-dependencies","title":"Git / Local Dependencies","text":"<p>To add a local or git dependency, you can pass additional parameters like <code>--path</code> or <code>--git</code>:</p> <pre><code>rye add Flask --git=https://github.com/pallets/flask\nrye add My-Utility --path ./my-utility\n</code></pre> <p>Note that when adding such dependencies, it's necessary to also provide the name of the package.  Additionally for git dependencies all kinds of extra parameters such as <code>--tag</code>, <code>--rev</code> or <code>--branch</code> are supported.</p> <p>When working with local dependencies it's strongly encouraged to configure a workspace.</p>"},{"location":"guide/faq/","title":"FAQ","text":"<p>This section should cover some commonly asked questions.  If you do not find an answer here, consider reaching out to the community.</p>"},{"location":"guide/faq/#windows-developer-mode","title":"Windows Developer Mode","text":"<p>Rye does not require symlinks but it works significantly better with them.  On Windows support for symlinks is restricted to privileged accounts.  The reason for this is that Symlinks were a late addition to Windows and some applications are not developed with them in mind which can cause misbehavior or in the worst case security issues in those applications.  Symlinks support however is enabled when the \"developer mode\" is activated on modern Windows versions.  Here is how you can enable it:</p> <ol> <li>Press Win+I to open the settings</li> <li>In the settings dialog click on \"Privacy &amp; security\"</li> <li>In the \"Security\" section click on \"For developers\"</li> <li>Enable the toggle \"Developer Mode\"</li> <li>In the \"Use developer features\" dialog confirm by clicking \"Yes\".</li> </ol> What happens if I don't enable it? <p>Enabling symlinks is not strictly required as Rye automatically falls back to hardlinks and junction points.  However not having symlinks enabled will ultimately result in a worse user experience for the following reasons:</p> <ul> <li>Custom toolchain registration uses proxy files rather than actual symlinks which   means that the executables in the <code>.rye\\py</code> path are non executable.</li> <li>All shims will be installed as hardlinks.  This can cause issues when upgrading   Rye while Python is in use.  These hardlinks will also continue to point to older   Rye executables creating more hard drive usage.</li> <li>Virtualenvs will be created with copies rather than symlinks.</li> <li>Junction points are used where symlinks to directories are otherwise used.  Some   tools might accidentally not detect junction points which can cause deletion of   virtualenvs to accidentally also delete or destroy the toolchain behind it.</li> </ul>"},{"location":"guide/faq/#missing-shared-libraries-on-linux","title":"Missing Shared Libraries on Linux","text":"<p>The Python builds that Rye uses require a Linux installation compatible to the Linux Standard Base Core Specification (LSB).  Unfortunately not all Linux distributions are strictly adhering to that specification out of the box.  In particularly the library <code>libcrypt.so.1</code> is commonly not installed on certain Linux distributions but the <code>_crypt</code> standard library module depends on it. Depending on the Linux distributions you need to run different commands to resolve this:</p> <ul> <li>archlinux: <code>pacman -S libxcrypt-compat</code></li> <li>CentOS/RedHat: <code>dnf install libxcrypt-compat</code></li> </ul> <p>There have also been reports of an error being generated at installation time despite <code>libcrypt.so.1</code> being installed when a different <code>ldd</code> (eg: Homebrew) shadows the system one.  In that case try the installation again after giving the default one higher priority in the `PATH:</p> <pre><code>export PATH=\"/usr/bin:$PATH\"\ncurl -sSf https://rye-up.com/get | bash\n</code></pre>"},{"location":"guide/faq/#tkinter-support","title":"TKinter Support","text":"<p>TKinter uses TCL behind the scenes.  Unfortunately this also means that some runtime support is required.  This runtime support is provided by the portable Python builds, however the way TCL is initialized on macOS and Linux won't find these files in virtualenvs.  Newer versions of Rye will automatically export the <code>TCL_LIBRARY</code> and <code>TK_LIBRARY</code> environment variables for you in a manner very similar to this:</p> <pre><code>import os\nimport sys\nos.environ[\"TCL_LIBRARY\"] = sys.base_prefix + \"/lib/tcl8.6\"\nos.environ[\"TK_LIBRARY\"] = sys.base_prefix + \"/lib/tk8.6\"\n</code></pre>"},{"location":"guide/faq/#python-interactive-prompt-input-messed-up","title":"Python Interactive Prompt Input Messed Up","text":"<p>The Python builds that Rye uses are compiled against <code>libedit</code> rather than <code>readline</code> for licensing reasons.  You might run into unicode issues on input as a result of this due to limitations in <code>libedit</code>.  In some cases though you might also discover that the backspace key does not work or arrow keys don't work as expected.  This can be because the terminfo database cannot be found.</p> <p>For solutions to this issue, read the behavior quirks guide in the Standalone Python Builds documentation for solutions.</p>"},{"location":"guide/faq/#can-i-use-rye-alongside-other-python-installations","title":"Can I use Rye Alongside Other Python Installations?","text":"<p>Rye given it's experimental nature does not want to disrupt already existing Python workflows.  As such using it alongside other Python installations is intentionally supported.  Even if the Rye shims come first on the <code>PATH</code>, Rye will automatically resolve to a different Python installation on the search path when invoked in a folder that contains a non Rye managed project.</p> <p>As such the answer is a clear yes!</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Rye is built in Rust.  It can either be manually compiled and installed or it can be installed from a binary distribution yet.  It has support for Linux, macOS and Windows.</p>"},{"location":"guide/installation/#installing-rye","title":"Installing Rye","text":"<p>Rye is installed per-user and self manages itself.  It will install itself into a folder in your home directory and mange itself there.</p> LinuxmacOSWindowsCompile Yourself <p>To install run you can curl a command which will install the right binary for your operating system and CPU architecture and install it:</p> <pre><code>curl -sSf https://rye-up.com/get | bash\n</code></pre> <p>Alternatively if you don't trust this approach, you can download the latest release binary.  On first run it will install itself.</p> <ul> <li>rye-x86_64-linux.gz for 64bit Intel computers</li> <li>rye-aarch64-linux.gz for 64bit ARM computers</li> </ul> <pre><code>gunzip rye-x86_64-linux.gz\nchmod +x ./rye-x86_64-linux\n./rye-x86_64-linux\n</code></pre> <p>To install run you can curl a command which will install the right binary for your operating system and CPU architecture and install it:</p> <pre><code>curl -sSf https://rye-up.com/get | bash\n</code></pre> <p>Alternatively if you don't trust this approach, you can download the latest release binary.  On first run it will install itself.</p> <ul> <li>rye-aarch64-macos.gz for M1/M2 Macs</li> <li>rye-x86_64-macos.gz for Intel Macs</li> </ul> <pre><code>gunzip rye-aarch64-macos.gz\nchmod +x ./rye-aarch64-macos\n./rye-aarch64-macos\n</code></pre> <p>To install Rye on windows download the latest release and run the binary.  Upon first run it will install itself.  Please note that it's strongly recommended to have \"Developer Mode\" activated when using Rye and before starting the installation.  Learn more.</p> <ul> <li>rye-x86_64-windows.exe for 64bit Intel Windows</li> <li>rye-x86-windows.exe for 32bit Intel Windows</li> </ul> <p>Note</p> <p>Rye does not yet use signed binaries which means that you will need to allow the execution of the downloaded executable.  If there is no obvious way to do so, click on \"More info\" on the error message that shows up and then on \"Run anyway\".</p> <p>You need to have Rust and Cargo installed.  If you don't have, you can use rustup to get them onto your machine.</p> <p>Afterwards you can install <code>Rye</code> via <code>cargo</code>:</p> <pre><code>cargo install --git https://github.com/mitsuhiko/rye rye\n</code></pre> <p>Rye will automatically download suitable Python toolchains as needed.  For more information about this read about toolchains.  To install a specific version download a binary directly from GitHub.</p>"},{"location":"guide/installation/#customized-installation","title":"Customized Installation","text":"<p>On some platforms there is some limited support for customizing the installation experience.</p> LinuxmacOSWindows <p> The install script that is piped to <code>bash</code> can be customized with some environment variables:</p> <code>RYE_VERSION</code> <p>Defaults to <code>latest</code>.  Can be set to an explicit version to install a specific one.</p> <code>RYE_INSTALL_OPTION</code> <p>Can optionally be set to <code>\"--yes\"</code> to skip all prompts.</p> <code>RYE_TOOLCHAIN</code> <p>Optionally this environment variable can be set to point to a Python interpreter that should be used as the internal interpreter.  If not provided a suitable interpreter is automatically downloaded.</p> <p>At present only CPython 3.9 to 3.11 are supported.</p> <p>This for instance installs a specific version of Rye without asking questions:</p> <p><pre><code>curl -sSf https://rye-up.com/get | RYE_VERSION=\"0.4.0\" RYE_INSTALL_OPTION=\"--yes\" bash\n</code></pre> </p> <p> The install script that is piped to <code>bash</code> can be customized with some environment variables:</p> <code>RYE_VERSION</code> <p>Defaults to <code>latest</code>.  Can be set to an explicit version to install a specific one.</p> <code>RYE_INSTALL_OPTION</code> <p>Can optionally be set to <code>\"--yes\"</code> to skip all prompts.</p> <code>RYE_TOOLCHAIN</code> <p>Optionally this environment variable can be set to point to a Python interpreter that should be used as the internal interpreter.  If not provided a suitable interpreter is automatically downloaded.</p> <p>At present only CPython 3.9 to 3.11 are supported.</p> <p>This for instance installs a specific version of Rye without asking questions:</p> <p><pre><code>curl -sSf https://rye-up.com/get | RYE_VERSION=\"0.4.0\" RYE_INSTALL_OPTION=\"--yes\" bash\n</code></pre> </p> <p>The Windows installer has limited support for customizations via environment variables.  To set these you need to run the installer from <code>cmd.exe</code>.</p> <code>RYE_TOOLCHAIN</code> <p>Optionally this environment variable can be set to point to a Python interpreter that should be used as the internal interpreter.  If not provided a suitable interpreter is automatically downloaded.</p> <p>At present only CPython 3.9 to 3.11 are supported.</p> <p>This for instance installs Rye with a specific toolchain:</p> <pre><code>set RYE_TOOLCHAIN=%USERPROFILE%\\AppData\\Local\\Programs\\Python\\Python310\\python.exe\nrye-x86_64-windows.exe\n</code></pre>"},{"location":"guide/installation/#add-shims-to-path","title":"Add Shims to Path","text":"<p>Once <code>rye</code> is installed you need to add the <code>shims</code> folder into your <code>PATH</code>. This folder is a folder that contains \"shims\" which are executables that Rye manages for you as well as the <code>rye</code> executable itself.  For instance any Python installation managed by Rye will be available via a shim placed there.</p> <p>On macOS or Linux you can accomplish this by adding it to your <code>.bashrc</code>, <code>.zshrc</code> or similar.  This step is technically optional but required if you want to be able to just type <code>python</code> or <code>rye</code> into the shell to pick up the current virtualenv's Python interpreter.</p> BashZSHFishUnix ShellsWindows <p>Rye ships an <code>env</code> file which should be sourced to update <code>PATH</code> automatically.</p> <pre><code>echo 'source \"$HOME/.rye/env\"' &gt;&gt; ~/.bashrc\n</code></pre> <p>Rye ships an <code>env</code> file which should be sourced to update <code>PATH</code> automatically.</p> <pre><code>echo 'source \"$HOME/.rye/env\"' &gt;&gt; ~/.zshrc\n</code></pre> <p>Since fish does not support `env`` files, you instead need to add the shims directly.  This can be accomplished by running this command once:</p> <pre><code>set -Ua fish_user_paths \"$HOME/.rye/shims\"\n</code></pre> <p>Rye ships an <code>env</code> file which should be sourced to update <code>PATH</code> automatically.</p> <pre><code>echo '. \"$HOME/.rye/env\"' &gt;&gt; ~/.profile\n</code></pre> <p>To modify the Windows PATH environment variable</p> <ol> <li>Press Win+R, enter <code>sysdm.cpl</code> and hit Enter.</li> <li>In the \"System Properties\" dialog, click the \"Advanced\" tab.</li> <li>Click on \"Environment Variables\".</li> <li>In the top list, double click on the <code>Path</code> variable.</li> <li>In the \"Edit environment variable\" dialog click on \"New\".</li> <li>Enter <code>%USERPROFILE%\\.rye\\shims</code> and hit Enter.</li> <li>Click repeatedly on \"Move Up\" until the newly added item is at the top.</li> <li>Click on \"OK\" and close the dialog.</li> </ol> <p>Note that you might need to restart your login session for this to take effect.</p> <p>There is a quite a bit to shims and their behavior.  Make sure to read up on shims to learn more.</p>"},{"location":"guide/installation/#updating-rye","title":"Updating Rye","text":"<p>To update rye to the latest version you can use <code>rye</code> itself:</p> <pre><code>rye self update\n</code></pre>"},{"location":"guide/installation/#uninstalling","title":"Uninstalling","text":"<p>If you don't want to use Rye any more, you can ask it to uninstall it again:</p> <pre><code>rye self uninstall\n</code></pre> <p>Additionally you should delete the remaining <code>.rye</code> folder from your home directory and remove <code>.rye/shims</code> from the <code>PATH</code> again.  Rye itself does not place any data in other locations.  Note though that virtual environments created by rye will no longer function after Rye was uninstalled.</p>"},{"location":"guide/installation/#preventing-auto-installation","title":"Preventing Auto Installation","text":"<p>Rye when launched will normally perform an auto installation.  This can be annoying in certain development situations.  This can be prevented by exporting the <code>RYE_NO_AUTO_INSTALL</code> environment variable.  It needs to be set to <code>1</code> to disable the feature.</p> LinuxmacOSWindows <pre><code>export RYE_NO_AUTO_INSTALL=1\n</code></pre> <pre><code>export RYE_NO_AUTO_INSTALL=1\n</code></pre> <pre><code>set RYE_NO_AUTO_INSTALL=1\n</code></pre>"},{"location":"guide/publish/","title":"Building and Publishing","text":"<p>Rye currently uses build to build the package and uses twine to publish it.</p>"},{"location":"guide/publish/#build","title":"Build","text":"<p>By default, <code>rye</code> will build the both sdist and wheel target in the <code>dist</code> directory.</p> <pre><code>rye build\n</code></pre> <p>You can use the <code>--sdist</code> or <code>--wheel</code> flag to build the specific target, or specify the output directory with <code>--out</code>.</p> <pre><code>rye build --wheel --out target\n</code></pre> <p>If you want to clean the build directory before building, run:</p> <pre><code>rye build --clean\n</code></pre>"},{"location":"guide/publish/#publish","title":"Publish","text":"<p>Rye will publish the distribution files under the <code>dist</code> directory to PyPI by default.</p> <pre><code>rye publish\n</code></pre> <p>You might be asked to input your access token and some other info if needed.</p> <pre><code>No access token found, generate one at: https://pypi.org/manage/account/token/\nAccess token:\n</code></pre> <p>You can also specify the distribution files to be published:</p> <pre><code>rye publish dist/example-0.1.0.tar.gz\n</code></pre>"},{"location":"guide/publish/#-repository","title":"--repository","text":"<p>Rye supports publishing the package to a different repository by using the <code>--repository</code> and <code>--repository-url</code> flags. For example, to publish to the test PyPI repository:</p> <pre><code>rye publish --repository testpypi --repository-url https://test.pypi.org/legacy/\n</code></pre>"},{"location":"guide/publish/#-yes","title":"--yes","text":"<p>You can optionally set the <code>--yes</code> flag to skip the confirmation prompt. This can be useful for CI/CD pipelines.</p> <pre><code>rye publish --token &lt;your_token&gt; --yes\n</code></pre> <p>Rye will store your repository info in <code>$HOME/.rye/credentials</code> for future use.</p>"},{"location":"guide/pyproject/","title":"Python Project (<code>pyproject.toml</code>)","text":"<p>Rye tries to avoid a lot of proprietary configuration in the <code>pyproject.toml</code> file but a bit is necessary.  Here are the most important keys that Rye expects:</p>"},{"location":"guide/pyproject/#projectdependencies","title":"<code>project.dependencies</code>","text":"<p>This key is used to manage dependencies.  They work exactly like you expect from a regular <code>pyproject.toml</code> file and in fact Rye changes nothing about this.  However Rye is capable of modifying these entries with the <code>rye add</code> and <code>rye remove</code> commands.</p> <pre><code>[project]\ndependencies = [\n\"mkdocs~=1.4.3\",\n\"mkdocs-material~=9.1.12\",\n\"pymdown-extensions~=9.11\",\n]\n</code></pre>"},{"location":"guide/pyproject/#projectscripts","title":"<code>project.scripts</code>","text":"<p>This key specifies the scripts that are to be generated and installed into the virtual environment during <code>sync</code>. These scripts will invoke the configured entry point.</p> <p><pre><code>[project.scripts]\nmy-hello-script = 'hello:main'\n</code></pre> This configuration will generate a script <code>my-hello-script</code> that will call the <code>main</code> function of the <code>hello</code> module.</p> <p>Scripts can be installed using <code>rye sync</code> and run using <code>rye run</code>:</p> <pre><code>$ rye sync\n$ rye run my-hello-script\nHello from hello!\n</code></pre>"},{"location":"guide/pyproject/#toolryedev-dependencies","title":"<code>tool.rye.dev-dependencies</code>","text":"<p>This works similar to <code>project.dependencies</code> but holds development only dependencies.  These can be added here automatically via <code>rye add --dev</code>.</p> <pre><code>[tool.rye]\ndev-dependencies = [\"black~=23.3.0\"]\n</code></pre> <p>Dev dependencies are installed automatically unless <code>--no-dev</code> is passed to <code>sync</code>.</p>"},{"location":"guide/pyproject/#toolryeexcluded-dependencies","title":"<code>tool.rye.excluded-dependencies</code>","text":"<p>This is a special key that contains dependencies which are never installed, even if they are pulled in as indirect dependencies.  These are added here automatically with <code>rye add --excluded</code>.</p> <pre><code>[tool.rye]\nexcluded-dependencies = [\"cffi\"]\n</code></pre>"},{"location":"guide/pyproject/#toolryemanaged","title":"<code>tool.rye.managed</code>","text":"<p>new in 0.3.0</p> <p>This key tells rye that this project is supposed to be managed by Rye.  This key primarily affects some automatic creation of virtualenvs.  For instance Rye will not try to initialize a virtualenv when using shims without this flag.  It can be forced enabled in the global config.</p> <pre><code>[tool.rye]\nmanaged = true\n</code></pre>"},{"location":"guide/pyproject/#toolryesources","title":"<code>tool.rye.sources</code>","text":"<p>This is an array of tables with sources that should be used for locating dependencies. This lets you use indexes other than PyPI.  These sources can also be configured in the main <code>config.toml</code> config file with the same syntax.</p> <pre><code>[[sources]]\nname = \"default\"\nurl = \"http://pypi.org/simple/\"\n</code></pre> <p>For more information about configuring sources see Dependency Sources.</p>"},{"location":"guide/pyproject/#toolryescripts","title":"<code>tool.rye.scripts</code>","text":"<p>This key can be used to register custom scripts that are exposed via <code>rye run</code>.  Each key is a script, and each value is the configuration for that script.  Normally the value is an object with different keys with the most important key being <code>cmd</code> which holds the command to execute. However if only <code>cmd</code> is set, then the object is optional.  <code>cmd</code> itself can either be set to a string or an array of arguments.</p> <pre><code>[tool.rye.scripts]\n# These three options are equivalent:\ndevserver = \"flask run --app ./hello.py --debug\"\ndevserver-alt = [\"flask\", \"run\", \"--app\", \"./hello.py\", \"--debug\"]\ndevserver-explicit = { cmd = \"flask run --app ./hello.py --debug\" }\n</code></pre> <p>The following keys are possible for a script:</p>"},{"location":"guide/pyproject/#cmd","title":"<code>cmd</code>","text":"<p>The command to execute.  This is either a <code>string</code> or an <code>array</code> of arguments.  In either case shell specific interpolation is unavailable.  The command will invoke one of the tools in the virtualenv if it's available there.</p> <pre><code>[tool.rye.scripts]\ndevserver = { cmd = \"flask run --app ./hello.py --debug\" }\nhttp = { cmd = [\"python\", \"-mhttp.server\", \"8000\"] }\n</code></pre>"},{"location":"guide/pyproject/#env","title":"<code>env</code>","text":"<p>This key can be used to provide environment variables with a script:</p> <pre><code>[tool.rye.scripts]\ndevserver = { cmd = \"flask run --debug\", env = { FLASK_APP = \"./hello.py\" } }\n</code></pre>"},{"location":"guide/pyproject/#chain","title":"<code>chain</code>","text":"<p>This is a special key that can be set instead of <code>cmd</code> to make a command invoke multiple other commands.  Each command will be executed one after another.  If any of the commands fails the rest of the commands won't be executed and instead the chain fails.</p> <pre><code>[tool.rye.scripts]\nlint = { chain = [\"lint:black\", \"lint:flake8\" ] }\n\"lint:black\" = \"black --check src\"\n\"lint:flake8\" = \"flake8 src\"\n</code></pre>"},{"location":"guide/pyproject/#call","title":"<code>call</code>","text":"<p>This is a special key that can be set instead of <code>cmd</code> to make a command invoke python functions or modules.  The format is one of the three following formats:</p> <ul> <li><code>&lt;module_name&gt;</code>: equivalent to <code>python -m &lt;module_name&gt;</code></li> <li><code>&lt;module_name&gt;:&lt;function_name&gt;</code>: runs <code>&lt;function_name&gt;</code> from <code>&lt;module_name&gt;</code> and exits with the return value</li> <li><code>&lt;module_name&gt;:&lt;function_name&gt;(&lt;args&gt;)</code>: passes specific arguments to the function</li> </ul> <p>Extra arguments provided on the command line are passed in <code>sys.argv</code>.</p> <pre><code>[tool.rye.scripts]\nserve = { call = \"http.server\" }\nhelp = { call = \"builtins:help\" }\nhello-world = { call = \"builtins:print('Hello World!')\" }\n</code></pre>"},{"location":"guide/pyproject/#toolryeworkspace","title":"<code>tool.rye.workspace</code>","text":"<p>When a table with that key is stored, then a project is declared to be a workspace root.  By default all Python projects discovered in sub folders will then become members of this workspace and share a virtualenv.  Optionally the <code>members</code> key (an array) can be used to restrict these members.  In that list globs can be used.  The root project itself is always a member.</p> <pre><code>[tool.rye.workspace]\nmembers = [\"mylib-*\"]\n</code></pre>"},{"location":"guide/rust/","title":"Rust Modules","text":"<p>Rye recommends using maturin to develop Rust Python extension modules.  This process is largely automated and new projects can be created with <code>rye init</code>.</p>"},{"location":"guide/rust/#new-project","title":"New Project","text":"<pre><code>rye init my-project --build-system maturin\ncd maturin\n</code></pre> <p>The following structure will be created:</p> <pre><code>.\n\u251c\u2500\u2500 .git\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .python-version\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 python\n    \u2514\u2500\u2500 my_project\n        \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 lib.rs\n</code></pre>"},{"location":"guide/rust/#iterating","title":"Iterating","text":"<p>When you use maturin as a build system then <code>rye sync</code> will automatically build the rust extension module into your venv.  Likewise <code>rye build</code> will use maturin to trigger a wheel build.  For faster iteration it's recommended to use <code>maturin</code> directly.</p> <p>If you want to use other maturin commands such as <code>maturin develop</code> you can install it as a global tool:</p> <pre><code>rye install maturin\n</code></pre> <p>Note that <code>maturin develop</code> requires <code>pip</code> to be installed into the virtualenv.  Before you can use it you need to add it:</p> <pre><code>rye add --dev pip\nrye sync\n</code></pre> <p>Rye recommends mixed python/rust modules.  In that case you can save some valuable iteration time by running <code>maturin develop --skip-install</code>:</p> <pre><code>maturin develop --skip-install\n</code></pre>"},{"location":"guide/shims/","title":"Shims","text":"<p>After installation Rye places two shims on your <code>PATH</code>: <code>python</code> and <code>python3</code>.  These shims have specific behavior that changes depending on if they are used within a Rye managed project or outside.</p> <p>Inside a Rye managed project they resolve to the Python interpreter of the virtualenv. This means that even if you do not enable the virtualenv, you can just run <code>python</code> in a shell, and it will automatically operate in the right environment.</p> <p>Outside a Rye managed project it typically resolves to your system Python, though you can also opt to have it resolve to a Rye managed Python installation for you.  This is done so that it's not disruptive to your existing workflows which might depend on the System python installation.</p>"},{"location":"guide/shims/#global-shims","title":"Global Shims","text":"<p>new in 0.9.0</p> <p>To enable global shims, you need to enable the <code>global-python</code> flag in the <code>config.toml</code> file:</p> <pre><code>rye config --set-bool behavior.global-python=true\n</code></pre> <p>Afterwards if you run <code>python</code> outside of a Rye managed project it will spawn a Python interpreter that is shipped with Rye.  It will honor the closest <code>.python-version</code> file for you.  Additionally you can also explicitly request a specific Python version by adding <code>+VERSION</code> after the <code>python</code> command.  For instance this runs a script with Python 3.8:</p> <pre><code>python +3.8 my-script.py\n</code></pre> <p>Note</p> <p>Selecting a specific Python version this way only works outside of Rye managed projects.  Within Rye managed projects, the version needs to be explicitly selected via <code>.python-version</code> or with the <code>requires-python</code> key in <code>pyproject.toml</code>.</p>"},{"location":"guide/sources/","title":"Dependency Sources","text":"<p>new in 0.2.0</p> <p>Normally Rye loads packages from PyPI only.  However it is possible to instruct it to load packages from other indexes as well.</p>"},{"location":"guide/sources/#adding-a-source","title":"Adding a Source","text":"<p>An index can be added to a project or workspace (via <code>pyproject.toml</code>) or into the global config.  Rye will always consult both files where the <code>pyproject.toml</code> file wins over the global config.</p> <p>Each source needs to have a unique name.  The default source is always called <code>default</code> and out of the box points to PyPI.</p> Global SourceProject Source <p>Add this to <code>~/.rye/config.toml</code>:</p> <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"https://company.internal/simple/\"\n</code></pre> <p>Add this to <code>pyproject.toml</code>:</p> <pre><code>[[tool.rye.sources]]\nname = \"company-internal\"\nurl = \"https://company.internal/simple/\"\n</code></pre> <p>changed in 0.4.0</p> <p>Sources in the global config are also considered for tool installations.</p>"},{"location":"guide/sources/#index-types","title":"Index Types","text":"<p>Rye supports different types of sources and also allows overriding the <code>default</code> PyPI index.  If you give another source the name <code>default</code>, PyPI will no longer be used for resolution.</p> Regular IndexFind LinksDefault Index <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"https://company.internal/simple/\"\ntype = \"index\"  # this is implied\n</code></pre> <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"https://company.internal/\"\ntype = \"find-links\"\n</code></pre> <pre><code>[[sources]]\nname = \"default\"\nurl = \"https://company.internal/simple/\"\n</code></pre> <p>Warning</p> <p>Please take note that the default index cannot be of type <code>find-links</code>.</p>"},{"location":"guide/sources/#source-types","title":"Source Types","text":"<p>The two sources types (<code>index</code> vs <code>find-links</code>) are determined by the underlying pip infrastructure:</p>"},{"location":"guide/sources/#index","title":"<code>index</code>","text":"<p>This is a PEP 503 type index as provided by tools such as PyPI or devpi.  It corresponds to the arguments <code>--index-url</code> or <code>--extra-index-url</code> in pip.</p>"},{"location":"guide/sources/#find-links","title":"<code>find-links</code>","text":"<p>This is a source that can be of a variety of types and has to point to a file path or hosted HTML page linking to packages.  It corresponds to the <code>--find-links</code> argument.  The format of the HTML page is somewhat underspecified but generally all HTML links pointing to <code>.tar.gz</code> or <code>.whl</code> files are considered.</p>"},{"location":"guide/sources/#index-authentication","title":"Index Authentication","text":"<p>HTTP basic auth is supported for index authentication.  It can be supplied in two ways.  <code>username</code> and <code>password</code> can be directly embedded in the config, or they can be supplied with environment variables.</p> Configured CredentialsEnvironment Variables <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"https://company.internal/simple/\"\nusername = \"username\"\npassword = \"super secret\"\n</code></pre> <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"https://${INDEX_USERNAME}:${INDEX_PASSWORD}@company.internal/simple/\"\n</code></pre>"},{"location":"guide/sync/","title":"Syncing and Locking","text":"<p>Rye currently uses pip-tools to download and install dependencies.  For this purpose it creates two \"lockfiles\" (called <code>requirements.lock</code> and <code>requirements-dev.lock</code>).  These are not real lockfiles but they fulfill a similar purpose until a better solution has been implemented.</p> <p>Whenever <code>rye sync</code> is called, it will update lockfiles as well as the virtualenv.  If you only want to update the lockfiles, then <code>rye lock</code> can be used.</p>"},{"location":"guide/sync/#lock","title":"Lock","text":"<p>When locking, some options can be provided to change the locking behavior.  These flags are also all available on <code>rye sync</code>.</p>"},{"location":"guide/sync/#-update-update-all","title":"<code>--update</code> / <code>--update-all</code>","text":"<p>Updates a specific or all requirements to the latest and greatest version.  Without this flag a dependency will only be updated if necessary.</p> <pre><code>rye lock --update-all\n</code></pre>"},{"location":"guide/sync/#-features-all-features","title":"<code>--features</code> / <code>--all-features</code>","text":"<p>Python packages can have extra dependencies.  By default the local package that is installed will only be installed with the default features.  If for instance you have an extra dependency this will only be installed if the feature is enabled.</p> <pre><code>rye add --optional=web flask\nrye lock --features=web\n</code></pre> <p>When working with workspaces, the package name needs to be prefixed with a slash:</p> <pre><code>rye lock --features=package-name/feature-name\n</code></pre> <p>The <code>--features</code> parameter can be passed multiple times and features can also be comma separated.  To turn on all features, the <code>--all-features</code> parameter can be used.</p> <pre><code>rye lock --all-features\n</code></pre>"},{"location":"guide/sync/#-pre","title":"<code>--pre</code>","text":"<p>By default updates and version resolution will not consider pre-releases of packages.  If you do want to include those, pass <code>--pre</code></p> <pre><code>rye lock Flask --pre\n</code></pre>"},{"location":"guide/sync/#sync","title":"Sync","text":"<p>Syncing takes the same parameters as <code>lock</code> and then some.  Sync will usually first do what <code>lock</code> does and then use the lockfiles to update the virtualenv.</p>"},{"location":"guide/sync/#-no-lock","title":"<code>--no-lock</code>","text":"<p>To prevent the lock step from automatically running, pass <code>--no-lock</code>.</p> <pre><code>rye sync --no-lock\n</code></pre>"},{"location":"guide/sync/#-no-dev","title":"<code>--no-dev</code>","text":"<p>Only sync based on the production lockfile (<code>requirements.lock</code>) instead of the development lockfile (<code>requirements-dev.lock</code>).</p> <pre><code>rye sync --no-dev\n</code></pre>"},{"location":"guide/tools/","title":"Tools","text":"<p>Rye supports global tool installations.  This for instance allows you to install tools like <code>black</code> or <code>ruff</code> globally.</p>"},{"location":"guide/tools/#installing-tools","title":"Installing Tools","text":"<p>Use the <code>rye tools install</code> (aliased to <code>rye install</code>) command to install a tool globally with a shim:</p> <pre><code>rye install ruff\n</code></pre> <p>Afterwards the tool is installed into <code>~/.rye/tools/ruff</code> and the necessary shims are placed in <code>~/.rye/shims</code>.</p> <p>changed in 0.4.0</p> <p>The <code>install</code> command now considers custom sources configured in the <code>config.toml</code> file.  For more information see Dependency Sources.</p>"},{"location":"guide/tools/#extra-requirements","title":"Extra Requirements","text":"<p>Some tools do not declare all of their dependencies since they might be optional. In some cases these can be declared by passing extra features to the installer:</p> <pre><code>rye install black --features colorama\n</code></pre> <p>If dependencies are not at all specified, then they can be provided with <code>--extra-requirement</code>. This is particularly sometimes necessary if the tool uses <code>pkg_resources</code> (part of <code>setuptools</code>) but forgets to declare that dependency:</p> <pre><code>rye install gradio --extra-requirement setuptools\n</code></pre>"},{"location":"guide/tools/#listing-tools","title":"Listing Tools","text":"<p>If you want to see which tools are installed, you can use <code>rye tools list</code>:</p> <pre><code>rye tools list\n</code></pre> <pre><code>black\n  black\n  blackd\nruff\n  ruff\n</code></pre> <p>To also see which scripts those tools provide, also pass <code>--include-scripts</code></p> <pre><code>rye tools list --include-scripts\n</code></pre>"},{"location":"guide/tools/#uninstalling-tools","title":"Uninstalling Tools","text":"<p>To uninstall a tool again, use <code>rye tools uninstall</code> (aliased to <code>rye uninstall</code>):</p> <pre><code>rye uninstall black\n</code></pre>"},{"location":"guide/toolchains/","title":"Toolchain Management","text":"<p>Rye is unique in that it does not use system Python installations.  Instead if downloads and manages Python installations itself (called toolchains).  Today there are three types of toolchains supported by Rye and they require some understanding:</p> <ul> <li>Portable CPython: Rye will itself download portable builds of CPython   for most of its needs.  These are fetched from   indygreg/python-build-standalone</li> <li>Official PyPy Builds: PyPy is supported from the official release builds.</li> <li>Custom Local Toolchains: locally installed Python interpreters can be   registered with Rye.  Afterwards they can be used with any Rye managed project.</li> </ul>"},{"location":"guide/toolchains/#pinning-toolchains","title":"Pinning Toolchains","text":"<p>To make a project use a specific toolchain write the name of the toolchain into the <code>.python-version</code> file or use the <code>pin</code> command.  For pinning <code>cpython</code> the <code>cpython@</code> prefix can be omitted.</p> <pre><code>rye pin cpython@3.11.4\n</code></pre> <p>Pinning a downloadable version means that Rye will automatically fetch it when necessary. By default toolchains are pinned to a precise version.  This means that even if you write <code>rye pin cpython@3.11</code>, a very specific version of cpython is written into the <code>.python-version</code> file.  With Rye 0.5.0 onwards it's possible to perform \"relaxed\" pins:</p> <pre><code>rye pin --relaxed cpython@3.11\n</code></pre> <p>This will then persist <code>3.11</code> in the <code>.python-version</code> file and Rye will use the latest available compatible version for the virtual environment.</p> <p>changed in 0.5.0</p> <p>Relaxed pinning with <code>rye pin --relaxed</code> was added.</p>"},{"location":"guide/toolchains/#listing-toolchains","title":"Listing Toolchains","text":"<p>To see which toolchains are installed, <code>rye toolchain list</code> prints a list:</p> <p><pre><code>rye toolchain list\n</code></pre> <pre><code>cpython@3.11.1 (C:\\Users\\armin\\.rye\\py\\cpython@3.11.1\\install\\python.exe)\npypy@3.9.16 (C:\\Users\\armin\\.rye\\py\\pypy@3.9.16\\python.exe)\n</code></pre></p> <p>To see which toolchains can be installed, additionally pass the <code>--include-downloadable</code>:</p> <pre><code>rye toolchain list --include-downloadable\n</code></pre>"},{"location":"guide/toolchains/#fetching-toolchains","title":"Fetching Toolchains","text":"<p>Generally Rye automatically downloads toolchains, but they can be explicitly fetched with <code>rye toolchain fetch</code> (also aliased to <code>rye fetch</code>):</p> <pre><code>rye toolchain fetch cpython@3.8.5\n</code></pre> <p>Toolchains are fetched from two sources:</p> <ul> <li>Indygreg's Portable Python Builds for CPython</li> <li>PyPy.org for PyPy</li> </ul>"},{"location":"guide/toolchains/#registering-toolchains","title":"Registering Toolchains","text":"<p>Additionally it's possible to register an external toolchain with the <code>rye toolchain register</code> command.</p> <pre><code>rye toolchain register /path/to/python\n</code></pre> <p>The name of the toolchain is picked based on the interpreter.  For instance linking a regular cpython installation will be called <code>cpython@version</code>, whereas linking pypy would show up as <code>pypy@version</code>.  From Rye 0.5.0 onwards <code>-dbg</code> is appended to the name of the toolchain if it's a debug build.  To override the name you can pass <code>--name</code>:</p> <pre><code>rye toolchain register --name=custom /path/to/python\n</code></pre>"},{"location":"guide/toolchains/#removing-toolchains","title":"Removing Toolchains","text":"<p>To remove an already fetched toolchain run <code>rye toolchain remove</code>.  Note that this also works for linked toolchains:</p> <pre><code>rye toolchain remove cpython@3.8.5\n</code></pre> <p>Warning</p> <p>Removing an actively used toolchain will render the virtualenvs that refer to use broken.</p>"},{"location":"guide/toolchains/cpython/","title":"Portable CPython","text":"<p>Rye is capable (and prefers) to download its own Python distribution over what you might already have on your computer.  For CPython, the indygreg/python-build-standalone builds from the PyOxidizer project are used.</p> <p>The motivation for this is that it makes it easy to switch between Python versions, to have a common experience across different Rye users and to avoid odd bugs caused by changes in behavior.</p> <p>Unfortunately Python itself does not release binaries (or the right types of binaries) for all operating systems which is why Rye leverages the portable Python builds from PyOxidizer.</p> <p>Unlike many other Python versions you can install on your computer are non-portable which means that if you move them to a new location on your machine, or you copy it onto another computer (even with the same operating system) they will no longer run.  This is undesirable for what Rye wants to do. For one we want the same experience for any of the Python developers, no matter which operating system they used.  Secondly we want to enable self-contained Python builds later, which requires that the Python installation is portable.</p> <p>To achieve this, the Python builds we use come with some changes that are different from a regular Python build.</p>"},{"location":"guide/toolchains/cpython/#limitations","title":"Limitations","text":"<p>The following changes to a regular Python versions you should be aware of:</p> <ul> <li> <p><code>libedit</code> instead of <code>readline</code>: unfortunately <code>readline</code> is GPL2 licensed   and this is a hazard for redistributions.  As such, the portable Python   builds link against the more freely licensed <code>libedit</code> instead.</p> </li> <li> <p><code>dbm.gnu</code> is unavailable.  This is a rather uncommonly used module and the   standard library provides alternatives.</p> </li> </ul> <p>Additionally due to how these builds are created, there are some other quirks you might run into related to terminal support or TKinter.  Some of these issues are collected in the FAQ.  Additionally the Python Standalone Builds have a Behavior Quirks page.</p>"},{"location":"guide/toolchains/cpython/#sources","title":"Sources","text":"<p>Portable CPython builds are downloaded from GitHub (indygreg/python-build-standalone/releases) and SHA256 hashes are generally validated.  Some older versions might not have hashes available in which case the validation is skipped.</p>"},{"location":"guide/toolchains/cpython/#usage","title":"Usage","text":"<p>When you pin a Python version to <code>cpython@major.minor.patch</code> (or just <code>major.minor.patch</code>) then Rye will automatically download the right version for you whenever it is needed.  If a custom toolchain has already been registered with that name and version, that this is used instead.</p>"},{"location":"guide/toolchains/pypy/","title":"PyPy","text":"<p>PyPy is supported as alternative Python distribution. Like the portable CPython builds it's downloaded automatically.  The name for PyPy distributions is <code>pypy</code>.</p>"},{"location":"guide/toolchains/pypy/#limitations","title":"Limitations","text":"<p>PyPy has some limitations compared to regular Python builds when it comes to working with Rye.  Most specifically PyPy uses some internal pypi dependencies and you might notice warnings show up when syching.  PyPy also lags behind regular Python installations quite a bit these days so you likely need to target older Python packages.</p>"},{"location":"guide/toolchains/pypy/#sources","title":"Sources","text":"<p>PyPy builds are downloaded from downloads.python.org.  These downloads are not verified today.</p>"},{"location":"guide/toolchains/pypy/#usage","title":"Usage","text":"<p>When you pin a Python version to <code>pypy@major.minor.patch</code> then Rye will automatically download the right version for you whenever it is needed.  If a custom toolchain has already been registered with that name and version, that this is used instead.  Note that the version refers to the PyPy CPython version.</p> <p>That means for instance that PyPy 7.3.11 is identified as <code>pypy@3.9.16</code> as this is the Python version it provides.  As PyPy also lacks builds for some CPU architectures, not all platforms might provide the right PyPy versions. </p>"}]}